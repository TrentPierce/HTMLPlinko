<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Plinko — Browser Demo</title>
  <style>
    :root{ --bg:#0b0f14; --panel:#111820; --ink:#e6f1ff; --muted:#93a4ba; --accent:#5de4c7; --accent2:#7aa2f7; --danger:#ff6b6b; --ok:#26de81; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;background:radial-gradient(1200px 1200px at 10% -10%, #112233 0%, #0b0f14 55%, #080b0f 100%);color:var(--ink)}
    .wrap{display:grid;grid-template-columns:360px 1fr;gap:18px;max-width:1400px;margin:24px auto;padding:0 16px}
    @media (max-width: 980px){.wrap{grid-template-columns:1fr;}}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));border:1px solid rgba(255,255,255,0.06);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,0.25)}
    .left{padding:16px;display:flex;flex-direction:column;gap:14px}
    .row{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .row .grow{flex:1}
    h1{font-size:22px;margin:8px 0 0}
    label{font-size:12px;color:var(--muted)}
    input[type="number"], input[type="text"], select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.08);background:#0f141b;color:var(--ink);outline:none}
    input[type="range"]{width:100%}
    .btn{cursor:pointer;user-select:none;border:none;background:linear-gradient(135deg,var(--accent2),var(--accent));padding:12px 14px;border-radius:12px;color:#041014;font-weight:700;font-size:14px;transition:transform .05s ease}
    .btn:active{transform:translateY(1px)}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.14);color:var(--ink)}
    .stack{display:flex;gap:10px;flex-wrap:wrap}
    .pill{font-variant-numeric:tabular-nums;display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:#0d1320;border:1px solid rgba(255,255,255,0.08);color:var(--muted)}
    .legend{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px}
    canvas{width:100%;height:100%;display:block}
    .stage{position:relative;aspect-ratio:3/4;min-height:520px;border-radius:16px;overflow:hidden}
    .meter{display:grid;grid-template-columns:repeat(auto-fit, minmax(70px, 1fr));gap:6px;padding:12px}
    .meter .slot{background:#0d1220;border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:8px;text-align:center;font-size:12px;color:var(--muted)}
    .hit{color:var(--ink)}
    .good{color:var(--ok)}
    .bad{color:var(--danger)}
    .foot{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-top:1px solid rgba(255,255,255,0.06);gap:20px;flex-wrap:wrap}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    #testsOut{white-space:pre-wrap;background:#0b1220;border:1px dashed rgba(255,255,255,0.12);border-radius:10px;padding:10px;color:#cfe3ff;max-height:200px;overflow:auto}
  </style>
</head>
<body>
  <div class="wrap">
    <section class="card left">
      <h1>Plinko — Provably‑Fair Style Demo</h1>
      <div class="row"><label>Rows</label><div class="grow"><input id="rows" type="range" min="8" max="16" value="12"/></div><div class="pill"><span id="rowsOut">12</span></div></div>
      <div class="row">
        <label>Risk</label>
        <select id="risk" class="grow">
          <option value="low">Low</option>
          <option value="medium" selected>Medium</option>
          <option value="high">High</option>
        </select>
      </div>
      <div class="row"><label>Target RTP</label><div class="grow"><input id="rtp" type="range" min="90" max="99" value="97"/></div><div class="pill"><span id="rtpOut">97%</span></div></div>
      <div class="row"><label>House Edge</label><div class="grow"><input id="houseEdge" type="range" min="0" max="10" step="0.1" value="3.0"/></div><div class="pill"><span id="houseEdgeOut">3.0%</span></div></div>
      <div class="row"><label>Edge Bias</label><div class="grow"><input id="edgeBias" type="range" min="1" max="2" step="0.05" value="1.20"/></div><div class="pill"><span id="edgeBiasOut">1.20×</span></div></div>
      <div class="row"><label>Seed</label><input id="seed" type="text" value="demo-seed-123"/></div>
      <div class="row"><label>Bet</label><input id="bet" type="number" min="0.01" step="0.01" value="1.00"/></div>
      <div class="row"><label>Ball Speed</label><div class="grow"><input id="speed" type="range" min="0.8" max="3" step="0.1" value="1.6"/></div><div class="pill"><span id="speedOut">1.6×</span></div></div>
      <div class="stack">
        <button id="drop" class="btn grow">Drop Ball</button>
        <button id="auto10" class="btn ghost">Auto ×10</button>
        <button id="auto100" class="btn ghost">Auto ×100</button>
        <button id="runTests" class="btn ghost">Run Self‑Tests</button>
      </div>
      <div class="legend">
        <span class="pill">Balance: <strong class="mono" id="bal">1,000,000.00</strong></span>
        <span class="pill">Last: <strong class="mono" id="last">—</strong></span>
        <span class="pill">P/L: <strong class="mono" id="pl">0.00</strong></span>
        <span class="pill">House: <strong class="mono" id="house">0.00</strong></span>
        <span class="pill">Win% (theory): <strong class="mono" id="winpct">—</strong></span>
        <span class="pill">Nonce: <strong class="mono" id="nonce">0</strong></span>
      </div>
      <div class="legend" id="hitmap"></div>
      <div id="testsOut" style="display:none"></div>
      <div style="font-size:12px;color:var(--muted);margin-top:4px">Seeded RNG (xmur3 → mulberry32). Simple physics (gravity + peg collisions). No libs.</div>
    </section>

    <section class="card">
      <div class="stage" id="stage">
        <canvas id="board"></canvas>
      </div>
      <div class="meter" id="meter"></div>
      <div class="foot">
        <div style="font-size:12px;color:var(--muted)">Expected value uses binomial probabilities scaled to target RTP. Edge slots glow when hit.</div>
        <button id="reset" class="btn ghost">Reset</button>
      </div>
    </section>
  </div>

<script>
// ---------- Utilities ----------
const isFiniteNum = (v)=> Number.isFinite(v) && !Number.isNaN(v);

// ---------- Seeded RNG ----------
function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=h<<13|h>>>19;}return function(){h=Math.imul(h^h>>>16,2246822507);h=Math.imul(h^h>>>13,3266489909);return (h^h>>>16)>>>0;}}
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296;}}
function makeRNG(seedStr, nonce){const seed = xmur3(seedStr+"|"+nonce)();return mulberry32(seed);}

// ---------- Binomial helpers ----------
function nCr(n,k){if(k<0||k>n) return 0; k=Math.min(k,n-k); let num=1,den=1; for(let i=1;i<=k;i++){num*=(n-(k-i));den*=i;} return num/den;}
function binomProb(n,k){return nCr(n,k)/Math.pow(2,n)}

// ---------- Payout model ----------
function makeMultipliers(rows, risk, targetRtp, edgeBias){
  const k = risk==='low'?1.25: risk==='high'?2.1: 1.6;
  const slots = rows+1; const base = []; const center = rows/2;
  const bias = Math.max(1, +edgeBias || 1);
  for(let i=0;i<slots;i++){
    const d = Math.abs(i-center);
    const shaped = Math.pow(d, bias);
    base.push(Math.pow(k, shaped));
  }
  let expected=0; for(let i=0;i<slots;i++) expected += binomProb(rows,i)*base[i];
  const scale = (targetRtp/100)/expected;
  return base.map(v=> Math.max(0.01, +(v*scale).toFixed(2)));
}

// ---------- Canvas / Geometry ----------
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const stage = document.getElementById('stage');
let dpr = Math.max(1, window.devicePixelRatio||1);
let W=0,H=0;

function safeResize(){
  const rect = stage.getBoundingClientRect();
  let w = rect.width * dpr; let h = rect.height * dpr;
  if(!isFiniteNum(w) || w <= 0) w = (canvas.clientWidth||600) * dpr;
  if(!isFiniteNum(h) || h <= 0) h = (canvas.clientHeight||800) * dpr;
  if(!isFiniteNum(w) || !isFiniteNum(h) || w<=0 || h<=0){ w = 900 * dpr; h = 1200 * dpr; }
  W = Math.floor(w); H = Math.floor(h);
  canvas.width=W; canvas.height=H; canvas.style.width=(W/dpr)+'px'; canvas.style.height=(H/dpr)+'px';
}
function requestDraw(){ if(W>0 && H>0) draw(); }
const ro = new ResizeObserver(()=>{ dpr = Math.max(1, window.devicePixelRatio||1); safeResize(); layoutBoard(); renderMeter(); requestDraw(); });
ro.observe(stage);

// ---------- State ----------
const ui = {
  rows: document.getElementById('rows'), rowsOut: document.getElementById('rowsOut'),
  risk: document.getElementById('risk'), rtp: document.getElementById('rtp'), rtpOut: document.getElementById('rtpOut'),
  seed: document.getElementById('seed'), bet: document.getElementById('bet'),
  speed: document.getElementById('speed'), speedOut: document.getElementById('speedOut'),
  drop: document.getElementById('drop'), auto10: document.getElementById('auto10'), auto100: document.getElementById('auto100'), reset: document.getElementById('reset'),
  runTests: document.getElementById('runTests'), testsOut: document.getElementById('testsOut'),
  bal: document.getElementById('bal'), last: document.getElementById('last'), pl: document.getElementById('pl'), nonce: document.getElementById('nonce'),
  meter: document.getElementById('meter'), hitmap: document.getElementById('hitmap'),
  edgeBias: document.getElementById('edgeBias'), edgeBiasOut: document.getElementById('edgeBiasOut'),
  winpct: document.getElementById('winpct'),
  houseEdge: document.getElementById('houseEdge'), houseEdgeOut: document.getElementById('houseEdgeOut'),
  house: document.getElementById('house')
};

let state = {
  rows: +ui.rows.value,
  risk: ui.risk.value,
  rtp: +ui.rtp.value,
  seed: ui.seed.value,
  speed: +ui.speed.value,
  balance: 1000000,
  profit: 0,
  nonce: 0,
  multipliers: [],
  hits: [],
  pegs: [],
  slotsX: [],
  balls: [],
  floorY: 0,
  leftWall: 0,
  rightWall: 0,
  rowYs: [],
  rowMinX: [],
  rowMaxX: [],
  halfGap: 0,
  colGap: 0,
  rowGapEff: 0,
  edgeBias: 1.20,
  houseEdge: 3.0,
  house: 0
};

// Radii (colliders)
function radii(){ return { BALL: 8*dpr, PEG: 6*dpr }; }

function rebuild(){
  state.rows=+ui.rows.value; ui.rowsOut.textContent=state.rows;
  state.risk=ui.risk.value;
  // keep RTP and House Edge in sync (RTP = 100 - HouseEdge)
  state.rtp=+ui.rtp.value; state.houseEdge = +(100 - state.rtp).toFixed(1);
  ui.rtpOut.textContent=state.rtp+"%"; ui.houseEdgeOut.textContent = state.houseEdge.toFixed(1)+'%'; ui.houseEdge.value = String(state.houseEdge);
  state.seed=ui.seed.value;
  state.speed=+ui.speed.value; ui.speedOut.textContent=state.speed.toFixed(1)+'×';
  state.edgeBias = +ui.edgeBias.value; ui.edgeBiasOut.textContent = state.edgeBias.toFixed(2)+'×';
  state.multipliers = makeMultipliers(state.rows, state.risk, state.rtp, state.edgeBias);
  state.hits = new Array(state.rows+1).fill(0);
  ui.bal.textContent = state.balance.toFixed(2); ui.pl.textContent = (state.profit>=0?'+':'') + state.profit.toFixed(2); ui.house.textContent = state.house.toFixed(2);
  layoutBoard();
  renderMeter();
  renderHitmap();
  updateWinPct();
  requestDraw();
}

function layoutBoard(){
  if(!(W>0 && H>0)) return;
  const rows = state.rows; const {PEG, BALL} = radii();
  const marginTop = 40*dpr, marginSide = 40*dpr, marginBottom=120*dpr;
  const usableW = Math.max(100, W - marginSide*2);
  const usableH = Math.max(100, H - marginTop - marginBottom);

  // Requirement: clear space between peg edges = 1.25 × ball diameter
  const ballDiameter = BALL*2;
  const desiredClearGap = ballDiameter*1.25;
  const colGap = (PEG*2) + desiredClearGap;
  state.colGap = colGap;

  // Match vertical spacing to horizontal spacing between peg centers
  const rowGapEff = colGap; // vertical spacing equals horizontal spacing
  state.rowGapEff = rowGapEff;

  const centerX = W/2; // fixed bad assignment earlier
  const pegs=[]; const rowYs=[]; const rowMinX=[]; const rowMaxX=[];
  for(let r=0;r<rows;r++){
    const cols = r+1; const y = marginTop + (r+1)*rowGapEff; rowYs.push(y);
    const totalWidth = (cols-1)*colGap; const leftMost = centerX - totalWidth/2; const rightMost = centerX + totalWidth/2;
    // Expand envelope by ±BALL so clamp (env ± BALL) yields true outer edge
    rowMinX.push(leftMost - colGap/2 - BALL); rowMaxX.push(rightMost + colGap/2 + BALL);
    const row=[];
    for(let c=0;c<cols;c++){ const x = leftMost + c*colGap; row.push({x,y,r:PEG}); }
    pegs.push(row);
  }
  state.pegs = pegs; state.rowYs=rowYs; state.rowMinX=rowMinX; state.rowMaxX=rowMaxX; state.halfGap = colGap/2;

  const slots = rows+1; const lastRow = pegs[pegs.length-1] || [{x:centerX}];
  const slotsX=[]; for(let s=0;s<slots;s++){ const left = (lastRow[0].x ?? centerX) - colGap/2; slotsX.push(left + s*colGap); }
  state.slotsX = slotsX;
  // place floor just below final peg row
  const lastY = rowYs[rowYs.length-1] || marginTop;
  state.floorY = lastY + state.rowGapEff;
  state.leftWall = rowMinX[0];
  state.rightWall = rowMaxX[0];
}

// Envelope: min/max X at a given Y by interpolating between row bands
function getEnvelopeAtY(y){
  const {rowYs,rowMinX,rowMaxX} = state; const n = rowYs.length;
  if(n===0) return {min: W*0.4, max: W*0.6};
  if(y <= rowYs[0]) return {min: rowMinX[0], max: rowMaxX[0]};
  for(let i=0;i<n-1;i++){
    const y1=rowYs[i], y2=rowYs[i+1]; if(y>=y1 && y<=y2){
      const t = (y - y1) / Math.max(1, (y2 - y1));
      const min = rowMinX[i] + t*(rowMinX[i+1]-rowMinX[i]);
      const max = rowMaxX[i] + t*(rowMaxX[i+1]-rowMaxX[i]);
      return {min, max};
    }
  }
  const i = n-1; return {min: rowMinX[i], max: rowMaxX[i]};
}

// ---------- Drawing ----------
function drawBG(){ if(!(W>0 && H>0)) return; const g=ctx.createLinearGradient(0,0,0,Math.max(1,H)); g.addColorStop(0,'rgba(90,140,255,0.08)'); g.addColorStop(1,'rgba(93,228,199,0.05)'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); }
function drawPegs(){ const {PEG}=radii(); ctx.save(); ctx.shadowColor='rgba(0,0,0,0.6)'; ctx.shadowBlur=10; for(const row of state.pegs){ for(const p of row){ ctx.beginPath(); ctx.arc(p.x,p.y,PEG,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fill(); } } ctx.restore(); }
function drawSlots(){ const y = state.floorY; ctx.save(); for(let i=0;i<state.slotsX.length;i++){ const x = state.slotsX[i]; ctx.beginPath(); ctx.moveTo(x, y-40*dpr); ctx.lineTo(x, y+18*dpr); ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=2*dpr; ctx.stroke(); const multVal = state.multipliers[i]; const mult = Number.isFinite(multVal) ? multVal : 0; const w = 58*dpr, h=28*dpr; const left = x - w/2, top = y+24*dpr; const rad = h/2; ctx.beginPath(); ctx.moveTo(left+rad,top); ctx.arcTo(left+w,top,left+w,top+h,rad); ctx.arcTo(left+w,top+h,left,top+h,rad); ctx.arcTo(left,top+h,left,top,rad); ctx.arcTo(left,top,left+w,top,rad); ctx.closePath(); const edgeFactor = Math.abs(i - state.rows/2); const c = Math.min(1, edgeFactor/(state.rows/2)); const base = `rgba(${120+60*c}, ${180-40*c}, ${255-40*c}, 0.18)`; ctx.fillStyle=base; ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.stroke(); ctx.fillStyle='rgba(230,241,255,0.95)'; ctx.font = `${12*dpr}px ui-monospace, Menlo, monospace`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(mult.toFixed(2)+'×', x, top+h/2); } ctx.restore(); }
function drawBalls(){
  const {BALL}=radii();
  const now = performance.now();
  for(const b of state.balls){
    let alpha = 1;
    if(b.finished && b.removeAt){
      if(now >= b.removeAt){
        const t = Math.min(1, (now - b.removeAt)/FADE_MS);
        alpha = 1 - t; // fade out after 3s timer
      }
    }
    ctx.save();
    ctx.globalAlpha = alpha;
    const glow = b.finished? 'rgba(93,228,199,0.7)' : 'rgba(122,162,247,0.7)';
    ctx.shadowColor=glow; ctx.shadowBlur=18*dpr;
    ctx.beginPath(); ctx.arc(b.x,b.y,BALL,0,Math.PI*2);
    ctx.fillStyle= b.finished? 'rgba(93,228,199,1)' : 'rgba(122,162,247,1)';
    ctx.fill();
    ctx.restore();
  }
}
function draw(){ if(!(W>0 && H>0)) return; ctx.clearRect(0,0,W,H); drawBG(); drawPegs(); drawSlots(); drawBalls(); }

// ---------- Physics Simulation ----------
const physics = { gravity: 2200, restitution: 0.2, friction: 0.995 };
const FADE_MS = 800; // fade duration after the 3s hold

function spawnBall(){ const {BALL}=radii(); const b = { x: W/2, y: BALL + 10*dpr, vx: 0, vy: 0, rng: makeRNG(state.seed, state.nonce), finished: false, slot: null, removeAt: null }; state.balls.push(b); }

let lastT = 0;
function stepAll(ts){
  if(!lastT) lastT = ts; let dt = (ts - lastT)/1000; dt = Math.min(dt, 1/30); lastT = ts;
  const {BALL}=radii(); const g = physics.gravity * state.speed * (dpr/1);

  for(const b of state.balls){
    if(b.finished) continue;
    // integrate
    b.vy += g*dt; b.x += b.vx*dt; b.y += b.vy*dt; b.vx *= physics.friction;

    // CONTAINMENT: clamp to current row envelope (plus ball radius)
    const env = getEnvelopeAtY(b.y);
    let minX = (env.min + BALL), maxX = (env.max - BALL);
    if(b.x < minX){ b.x = minX; b.vx = Math.abs(b.vx)*0.35; }
    if(b.x > maxX){ b.x = maxX; b.vx = -Math.abs(b.vx)*0.35; }

    // peg collisions
    for(const row of state.pegs){
      for(const p of row){
        const dx = b.x - p.x, dy = b.y - p.y; const dist = Math.hypot(dx,dy);
        const minD = BALL + p.r; if(dist>0 && dist < minD){
          const nX = dx/dist, nY = dy/dist; const overlap = (minD - dist) + 0.01; b.x += nX * overlap; b.y += nY * overlap;
          const vn = b.vx*nX + b.vy*nY; const rest = physics.restitution; b.vx -= (1+rest)*vn*nX; b.vy -= (1+rest)*vn*nY;
          const k = (b.rng()-0.5)*30*state.speed; b.vx += k;
        }
      }
    }

    // floor & landing into nearest slot
    const floor = state.floorY - BALL;
    if(b.y >= floor){ b.y = floor; b.vx = 0; b.vy = 0; const xs = state.slotsX; let best=0, bestd=Infinity; for(let i=0;i<xs.length;i++){ const d = Math.abs(b.x - xs[i]); if(d<bestd){bestd=d; best=i;} } b.slot = best; b.finished = true; onBallLanded(b); }
  }

  // Remove balls 3s + fade after landing
  state.balls = state.balls.filter(bb => !(bb.finished && bb.removeAt && performance.now() >= bb.removeAt + FADE_MS));

  draw(); requestAnimationFrame(stepAll);
}

// ---------- Game Flow ----------
function dropBall(){
  if(!(W>0 && H>0)) return;
  const bet = Math.max(0.01, +ui.bet.value||1);
  state.balance = +(state.balance - bet).toFixed(2);
  state.profit = +(state.profit - bet).toFixed(2);
  ui.bal.textContent = state.balance.toFixed(2);
  ui.pl.textContent = (state.profit>=0?'+':'') + state.profit.toFixed(2);
  spawnBall();
}

function onBallLanded(b){
  const bet = Math.max(0.01, +ui.bet.value||1);
  const mult = Number(state.multipliers[b.slot] ?? 0);
  const win = +(bet*mult).toFixed(2);
  // player settle
  state.balance = +(state.balance + win).toFixed(2);
  state.profit = +(state.profit + win).toFixed(2);
  // house settle (house earns bet - win)
  const houseDelta = +(bet - win).toFixed(2);
  state.house = +(state.house + houseDelta).toFixed(2);

  state.hits[b.slot]++;
  ui.bal.textContent = state.balance.toFixed(2);
  ui.last.textContent = `${win.toFixed(2)} (${mult.toFixed(2)}×)`;
  ui.pl.textContent = (state.profit>=0?'+':'') + state.profit.toFixed(2);
  ui.house.textContent = state.house.toFixed(2);
  flashSlot(b.slot);
  renderHitmap();
  b.removeAt = performance.now() + 3000;
}

function flashSlot(idx){ const meter = ui.meter.querySelector(`[data-slot="s${idx}"]`); if(!meter) return; meter.classList.add('hit'); setTimeout(()=>meter.classList.remove('hit'), 450); }

// ---------- Meter & stats ----------
function renderMeter(){ const el = ui.meter; el.innerHTML=''; const slots = state.rows+1; for(let i=0;i<slots;i++){ const p = (binomProb(state.rows,i)*100).toFixed(2); const multVal = state.multipliers[i]; const mult = Number.isFinite(multVal) ? multVal : 0; const div = document.createElement('div'); div.className='slot'; div.dataset.slot = 's'+i; const cls = mult>=1? 'good':'bad'; div.innerHTML = `<div class="mono ${cls}">${mult.toFixed(2)}×</div><div style="font-size:11px;color:var(--muted)">${p}%</div>`; el.appendChild(div); } }
function renderHitmap(){ const el = ui.hitmap; el.innerHTML=''; const total = state.hits.reduce((a,b)=>a+b,0)||1; state.hits.forEach((h,i)=>{ const pct = (h/total*100).toFixed(1); const multVal = state.multipliers[i]; const mult = Number.isFinite(multVal) ? multVal : 0; const chip = document.createElement('span'); chip.className='pill'; const cls = mult>=1? 'good':'bad'; chip.innerHTML = `<strong class="mono ${cls}">${i}</strong> <span class="mono">${h}</span> <span style="color:var(--muted)">${pct}%</span>`; el.appendChild(chip); }); }

function theoreticalWinRate(){ let p=0; for(let i=0;i<=state.rows;i++){ if(state.multipliers[i] >= 1){ p += binomProb(state.rows, i); } } return +(p*100).toFixed(2); }
function updateWinPct(){ ui.winpct.textContent = theoreticalWinRate().toFixed(2)+'%'; }

// ---------- Self‑tests ----------
function runSelfTests(){ const out = []; const ok = (name, cond)=> out.push(`${cond?'✅':'❌'} ${name}`);
  ok('Canvas size finite', isFiniteNum(W) && isFiniteNum(H) && W>0 && H>0);
  try{ const g = ctx.createLinearGradient(0,0,0,Math.max(1,H)); ok('Gradient args finite', !!g); }catch(e){ ok('Gradient args finite', false); }
  let s=0; for(let i=0;i<=state.rows;i++) s+=binomProb(state.rows,i); ok('Binomial sum ≈ 1', Math.abs(1-s) < 1e-9);
  ok('Multipliers length', state.multipliers.length === state.rows+1);
  ok('Multipliers defined', state.multipliers.every(m=> Number.isFinite(m)));
  ok('Multipliers > 0', state.multipliers.every(m=>m>0));
  // Spacing rule (horizontal)
  const {BALL, PEG}=radii(); const ballDiameter = BALL*2; const desiredClear = ballDiameter*1.25; const clearGap = state.colGap - 2*PEG; ok('Clear gap == 1.25×D (±1px)', Math.abs(clearGap - desiredClear) < 1*dpr + 0.001);
  // No NaNs in geometry
  ok('No NaN in colGap/rowGap', Number.isFinite(state.colGap) && Number.isFinite(state.rowGapEff));
  // Vertical spacing equals horizontal spacing
  ok('rowGap == colGap (±1px)', Math.abs(state.rowGapEff - state.colGap) < 1*dpr + 0.001);
  // Apex clearance
  const centerX = W/2; const envMin = state.rowMinX[0] + BALL; const envMax = state.rowMaxX[0] - BALL; const canLeft = envMin <= centerX - (PEG + BALL*0.99); const canRight = envMax >= centerX + (PEG + BALL*0.99); ok('Apex clearance (left)', canLeft); ok('Apex clearance (right)', canRight);
  // Landed balls tagged
  ok('Finished balls tagged for removal', state.balls.filter(b=>b.finished).every(b=> Number.isFinite(b.removeAt)) || state.balls.filter(b=>b.finished).length===0);
  // Functions exist
  ok('dropBall is function', typeof dropBall === 'function');
  ok('onBallLanded is function', typeof onBallLanded === 'function');
  // UI mirrors state
  ok('UI balance sync', ui.bal.textContent === state.balance.toFixed(2));
  // Fade tests
  ok('Fade constant defined', typeof FADE_MS === 'number' && FADE_MS > 0);
  ok('Removal waits for fade', state.balls.every(b => !(b.finished && b.removeAt && performance.now() >= b.removeAt) || state.balls.includes(b)));
  // Theoretical win rate sanity
  const wr = theoreticalWinRate(); ok('Win% sane', Number.isFinite(wr) && wr>=0 && wr<=100);
  // House tracker sane
  ok('House tracker exists', typeof state.house === 'number' && Number.isFinite(state.house));
  ok('House UI mirrors state', ui.house.textContent === state.house.toFixed(2));
  // RTP vs HouseEdge sync
  ok('RTP-houseEdge sync', Math.abs((100 - state.houseEdge) - state.rtp) < 0.11);

  ui.testsOut.style.display='block'; ui.testsOut.textContent = out.join('\n'); }

// ---------- Wiring ----------
ui.rows.addEventListener('input', rebuild);
ui.risk.addEventListener('change', rebuild);
ui.rtp.addEventListener('input', ()=>{ state.rtp = +ui.rtp.value; state.houseEdge = +(100 - state.rtp).toFixed(1); ui.rtpOut.textContent = state.rtp+'%'; ui.houseEdge.value = String(state.houseEdge); ui.houseEdgeOut.textContent = state.houseEdge.toFixed(1)+'%'; state.multipliers = makeMultipliers(state.rows, state.risk, state.rtp, state.edgeBias); renderMeter(); updateWinPct(); requestDraw(); });
ui.houseEdge.addEventListener('input', ()=>{ state.houseEdge = +ui.houseEdge.value; ui.houseEdgeOut.textContent = state.houseEdge.toFixed(1)+'%'; state.rtp = +(100 - state.houseEdge).toFixed(1); ui.rtp.value = String(state.rtp); ui.rtpOut.textContent = state.rtp+'%'; state.multipliers = makeMultipliers(state.rows, state.risk, state.rtp, state.edgeBias); renderMeter(); updateWinPct(); requestDraw(); });
ui.seed.addEventListener('change', rebuild);
ui.speed.addEventListener('input', ()=>{ state.speed=+ui.speed.value; ui.speedOut.textContent=state.speed.toFixed(1)+'×'; });
ui.edgeBias.addEventListener('input', ()=>{ state.edgeBias = +ui.edgeBias.value; ui.edgeBiasOut.textContent = state.edgeBias.toFixed(2)+'×'; state.multipliers = makeMultipliers(state.rows, state.risk, state.rtp, state.edgeBias); renderMeter(); updateWinPct(); requestDraw(); });
ui.runTests.addEventListener('click', runSelfTests);
ui.drop.addEventListener('click', ()=>{ state.nonce++; ui.nonce.textContent=state.nonce; dropBall(); });
ui.auto10.addEventListener('click', ()=> autoRun(10)); ui.auto100.addEventListener('click', ()=> autoRun(100));
ui.reset.addEventListener('click', ()=>{ state.balance=1000000; state.profit=0; state.house=0; state.nonce=0; ui.bal.textContent='1000000.00'; ui.pl.textContent='0.00'; ui.house.textContent='0.00'; ui.nonce.textContent='0'; state.hits.fill(0); state.balls=[]; rebuild(); renderHitmap(); updateWinPct(); draw(); });
function autoRun(n){ const run = ()=>{ if(n<=0) return; state.nonce++; ui.nonce.textContent=state.nonce; dropBall(); n--; setTimeout(run, 120); }; run(); }

// ---------- Init ----------
window.addEventListener('DOMContentLoaded', ()=>{ safeResize(); rebuild(); requestAnimationFrame(stepAll); });
</script>
</body>
</html>
